<div class="chatlog__message-group">
  <div id="chatlog__message-container-877237008869781504" class="chatlog__message-container" data-message-id="877237008869781504">
    <div class="chatlog__message">
      <div class="chatlog__message-aside"><img class="chatlog__avatar" src="https://cdn.discordapp.com/avatars/189711109966659584/95280765d1be73ce985dce15ea3585f6.png?size=512" alt="Avatar" loading="lazy"></div>
      <div class="chatlog__message-primary">
        <div class="chatlog__header"><span class="chatlog__author" style="color:rgb(237,171,161)" title="omochimetaru" data-user-id="189711109966659584">omochimetaru</span> <a href="/channels/472019265369669634?category=main&amp;channel=swiftc&amp;message_id=877237008869781504"><span class="chatlog__timestamp"></span></a><a href="#chatlog__message-container-877237008869781504">08/17/2021 5:06 PM</a></div>
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve">
            <div class="chatlog__markdown-quote">
              <div class="chatlog__markdown-quote-border"></div>
              <div class="chatlog__markdown-quote-content">Instead of trying to represent generic parameters and resilient types indirectly, have you tried instantiating the layout bytecode for generic and resilient types when their metadata is instantiated? Another benefit of a bytecode representation is that we can generate new ones at runtime, and one of the big performance sinks for unspecialized code is deeply-nested unspecialized value witness calls through many layers of generic or resilient type expansion. We could instead flatten all of that indirection at metadata instantiation time.</div>
            </div>
          </span></div>
      </div>
    </div>
  </div>
</div>