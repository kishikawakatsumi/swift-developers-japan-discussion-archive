<div class="chatlog__message-group">
  <div id="chatlog__message-container-1233764711451983922" class="chatlog__message-container" data-message-id="1233764711451983922">
    <div class="chatlog__message">
      <div class="chatlog__message-aside"><img class="chatlog__avatar" src="https://cdn.discordapp.com/avatars/293624673265123328/accd07acc220a18568ba46a6e9ede18a.png?size=512" alt="Avatar" loading="lazy"></div>
      <div class="chatlog__message-primary">
        <div class="chatlog__header"><span class="chatlog__author" style="color:rgb(17,128,106)" title="koher" data-user-id="293624673265123328">koher</span> <a href="/channels/499393715140558881?category=コミュニティ&amp;channel=swift-zoomin&amp;message_id=1233764711451983922"><span class="chatlog__timestamp" title="Saturday, April 27, 2024 1:00 PM"></span></a><a href="#chatlog__message-container-1233764711451983922">4/27/2024 1:00 PM</a></div>
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve"><code class="chatlog__markdown-pre chatlog__markdown-pre--multiline language-swift">func foo(values: [Int]) throws { if values.isEmpty { return } let shuffled = values.shuffled() guard let first = shuffled.first else { // preconditionFailure("...") try foo() } } do { let array = [2, 3, 5] let a: Int = array[0] let dictionary = ["a": 2, "b": 3, "c": 5] let b: Int? = dictionary["a"] } extension Array where Element: Comparable { mutating func mySort() { for i in indices { for j in indices.dropFirst(i) { // guard let a = self[i], let b = self[j] else { // // ??? // } if self[j] &lt; self[i] { // let t = self[i] // self[i] = self[j] // self[j] = t swapAt(i, j) } } } } } var array = [3, 2, 7, 5] array.mySort() print(array) //extension Array { // func subscript(index: Int) -&gt; Element { // precondition(indices.contains(index), "Index out of range.") // // } //} struct FooError: Error {} func foo() throws -&gt; Never { throw FooError() } print(Array(zip([2, 3, 5, 7], ["a", "b", "c"]))) func myZip&lt;T, U&gt;(_ ts: [T], _ us: [U]) -&gt; [(T, U)] { var result: [(T, U)] = [] for i in ts.indices { guard us.indices.contains(i) else { break } result.append((ts[i], us[i])) } assert(result.count == min(ts.count, us.count)) return result }</code></span></div>
      </div>
    </div>
  </div>
</div>