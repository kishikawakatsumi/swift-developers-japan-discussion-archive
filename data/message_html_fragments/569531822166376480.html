<div class="chatlog__message-group">
  <div id="chatlog__message-container-569529026721480719" class="chatlog__message-container" data-message-id="569529026721480719">
    <div class="chatlog__message">
      <div class="chatlog__message-aside"><img class="chatlog__avatar" src="https://cdn.discordapp.com/avatars/291075091025100810/39d60f97ea2bca395f1992c42f25107c.png?size=512" alt="Avatar" loading="lazy"></div>
      <div class="chatlog__message-primary">
        <div class="chatlog__header"><span class="chatlog__author" style="color:rgb(155,89,182)" title="kishikawakatsumi#7600" data-user-id="291075091025100810">Kishikawa Katsumi</span> <a href="/channels/472019265369669634?category=main&amp;channel=swiftc&amp;message_id=569533113370411038"><span class="chatlog__timestamp"></span></a><a href="#chatlog__message-container-569529026721480719">04/21/2019 2:25 PM</a></div>
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve">この段階でテキストがトークンに分割されたものが手に入ります。 <code class="chatlog__markdown-pre chatlog__markdown-pre--multiline nohighlight">▿ 1498 elements ▿ 0 : ( ▿ 1 : source_file ▿ 2 : "/Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift" ▿ 3 : __ ▿ 4 : ( ▿ 5 : struct_decl ▿ 6 : range ▿ 7 : = ▿ 8 : /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:1:8 - line:17:1 ▿ 9 : "Country" ▿ 10 : interface ▿ 11 : type ▿ 12 : = ▿ 13 : 'Country.Type' ...</code></span></div>
      </div>
    </div>
  </div>
  <div id="chatlog__message-container-569529354183507991" class="chatlog__message-container" data-message-id="569529354183507991">
    <div class="chatlog__message">
      <div class="chatlog__message-aside">
        <div class="chatlog__short-timestamp" title="04/21/2019 2:26 PM">14:26</div>
      </div>
      <div class="chatlog__message-primary">
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve"><code class="chatlog__markdown-pre chatlog__markdown-pre--inline">ASTLexer</code> がこのトークンの配列をツリー構造にします。Lexerといってますが、ツリー構造に変換するだけです。</span></div>
      </div>
    </div>
  </div>
  <div id="chatlog__message-container-569530160848830464" class="chatlog__message-container" data-message-id="569530160848830464">
    <div class="chatlog__message">
      <div class="chatlog__message-aside">
        <div class="chatlog__short-timestamp" title="04/21/2019 2:29 PM">14:29</div>
      </div>
      <div class="chatlog__message-primary">
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve"><code class="chatlog__markdown-pre chatlog__markdown-pre--multiline nohighlight">[(, source_file, "/Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift"] [(, struct_decl, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:1:8 - line:17:1, "Country", interface, type, =, 'Country.Type', access, =, public, non-resilient] [(, pattern_binding_decl, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:12 - line:2:22] [(, pattern_typed, type, =, 'String'] [(, pattern_named, type, =, 'String', 'code', )] [(, type_ident] [(, component, id, =, 'String', bind, =, Swift.(file).String))))] [(, var_decl, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:16 - line:2:16, "code", type, =, 'String', interface, type, =, 'String', access, =, public, let, readImpl, =, stored, immutable] [(, accessor_decl, implicit, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:16 - line:2:16, 'anonname=0x10a8205a8', interface, type, =, '(Country) -&gt; () -&gt; String', access, =, public, get_for, =, code] [(, parameter, "self", interface, type, =, 'Country', )] [(, parameter_list, )] [(, brace_stmt, implicit, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:16 - line:2:16] [(, return_stmt, implicit] ...</code> こんな感じです。これでツリー構造とノードの種別や属性情報がプログラムから扱える形になりました。</span></div>
      </div>
    </div>
  </div>
  <div id="chatlog__message-container-569531822166376480" class="chatlog__message-container" data-message-id="569531822166376480">
    <div class="chatlog__message">
      <div class="chatlog__message-aside">
        <div class="chatlog__short-timestamp" title="04/21/2019 2:36 PM">14:36</div>
      </div>
      <div class="chatlog__message-primary">
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve">ここまではそんなに難しくなくて、大変なのはソースコードから生成されるASTが難しいので、この情報を使っていくところです。 わかりやすいところで<code class="chatlog__markdown-pre chatlog__markdown-pre--inline">struct_decl</code>とか<code class="chatlog__markdown-pre chatlog__markdown-pre--inline">var_decl</code>、<code class="chatlog__markdown-pre chatlog__markdown-pre--inline">call_expr</code>、<code class="chatlog__markdown-pre chatlog__markdown-pre--inline">member_ref_expr</code>、<code class="chatlog__markdown-pre chatlog__markdown-pre--inline">dot_syntax_call_expr</code>などです。それ以外に膨大な種類のノードがあるので、全部に対応するのはとても大変なので、必要に応じてノードをフィルタして使っていく、というのが良いかと私は考えています。</span></div>
      </div>
    </div>
  </div>
  <div id="chatlog__message-container-569533108232257536" class="chatlog__message-container" data-message-id="569533108232257536">
    <div class="chatlog__message">
      <div class="chatlog__message-aside">
        <div class="chatlog__short-timestamp" title="04/21/2019 2:41 PM">14:41</div>
      </div>
      <div class="chatlog__message-primary">
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve">その必要なところだけ使う、というのをやっているのがASTParserで、 <code class="chatlog__markdown-pre chatlog__markdown-pre--multiline nohighlight">private func parseSourceFileNode(node sourceFileNode: ASTNode&lt;[ASTToken]&gt;) -&gt; AST { var declarations = [Declaration]() for node in sourceFileNode.children { for token in node.value { switch (token.type, token.value) { case (.token, "top_level_code_decl"): declarations.append(.topLevelCode(parseTopLevelCodeDeclarationNode(node: node))) case (.token, "import_decl"): declarations.append(.import(parseImportDeclarationNode(node: node))) case (.token, "struct_decl"): declarations.append(.struct(parseStructDeclarationNode(node: node))) case (.token, "class_decl"): declarations.append(.class(parseClassDeclarationNode(node: node))) case (.token, "enum_decl"): declarations.append(.enum(parseEnumDeclarationNode(node: node))) case (.token, "extension_decl"): declarations.append(.extension(parseExtensionDeclarationNode(node: node))) case (.token, "func_decl"): declarations.append(.function(parseFunctionDeclarationNode(node: node))) default: break } } } return AST(declarations: declarations) }</code> のようにまずStructやClass宣言を拾って、そのあと例えば関数だったら</span></div>
      </div>
    </div>
  </div>
  <div id="chatlog__message-container-569533113370411038" class="chatlog__message-container" data-message-id="569533113370411038">
    <div class="chatlog__message">
      <div class="chatlog__message-aside">
        <div class="chatlog__short-timestamp" title="04/21/2019 2:41 PM">14:41</div>
      </div>
      <div class="chatlog__message-primary">
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve"><code class="chatlog__markdown-pre chatlog__markdown-pre--multiline nohighlight">private func parseFunctionDeclarationNode(node: ASTNode&lt;[ASTToken]&gt;) -&gt; FunctionDeclaration { let tokens = node.value let name = parseString(tokens: tokens) ?? parseSymbol(tokens: tokens) let accessLevel = parseAccessLevel(tokens: tokens) var parameters = [Parameter]() var body = [Statement]() for node in node.children { for token in node.value { switch (token.type, token.value) { case (.token, "parameter_list"): parameters.append(contentsOf: parseParameterListNode(node: node)) case (.token, "brace_stmt"): body.append(.expression(parseExpressionNode(node: node))) default: break } } } return FunctionDeclaration(accessLevel: accessLevel, name: name!, parameters: parameters, body: body) }</code> パラメータやステートメントをさらに拾っていく、としています。 一番大変なのがこのParser部分を作っていくところだと思います。ここは自分が利用する情報を探しながらトライアルアンドエラーで書いていくことになります。</span></div>
      </div>
    </div>
  </div>
</div>