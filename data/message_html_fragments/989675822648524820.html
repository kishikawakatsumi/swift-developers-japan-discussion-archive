<div class="chatlog__message-group">
  <div id="chatlog__message-container-989675822648524820" class="chatlog__message-container" data-message-id="989675822648524820">
    <div class="chatlog__message">
      <div class="chatlog__message-aside">
        <div class="chatlog__reference-symbol"></div><img class="chatlog__avatar" src="https://cdn.discordapp.com/avatars/293624673265123328/accd07acc220a18568ba46a6e9ede18a.png?size=512" alt="Avatar" loading="lazy">
      </div>
      <div class="chatlog__message-primary">
        <div class="chatlog__reference"><img class="chatlog__reference-avatar" src="https://cdn.discordapp.com/avatars/506800600672108554/f342ba45362a4db2d7b0d2b66c02e365.png?size=512" alt="Avatar" loading="lazy">
          <div class="chatlog__reference-author" title="shibastripe#8957">shibastripe</div>
          <div class="chatlog__reference-content"><span class="chatlog__reference-link" onclick="scrollToMessage(event,'989551361643393065')"> 夜分遅くに失礼します。 <a href="https://github.com/koher/login-challenge-slides">https://github.com/koher/login-challenge-slides</a> 以前のswift-zoominを復習していてどう解決すべきかわからず気になりご意見をお聞きできないでしょうか？ 型パラメータのInjectionを用いて、<code class="chatlog__markdown-pre chatlog__markdown-pre--inline">@StateObject private var state: HomeViewState&lt;UserService&gt;</code> ObservableObject を用意すると、Usecase層のモックが非常にやりやすくてすごく良かったのですが、 例えばViewのスナップショットテストを実現したいと思ったときに、SwiftUIのViewやUIViewControllerでこのObservableObjectのUserServiceをモックしようとすると、ViewのPropertyは具象のUserServiceに依存してしまっていて、モックが困難に感じます。 現状Propertyに型パラメータをProtocolのまま持たせることはできないと思っているのですが、Swift@5.7のanyなどが入るとこういった問題を解決できたりするのでしょうか？ </span> <span class="chatlog__reference-edited-timestamp" title="23-Jun-22 03:24 PM">(edited)</span></div>
        </div>
        <div class="chatlog__header"><span class="chatlog__author" style="color:rgb(17,128,106)" title="koher#9336" data-user-id="293624673265123328">koher</span> <a href="/channels/499393715140558881?category=コミュニティ&amp;channel=swift-zoomin&amp;message_id=989675822648524820"><span class="chatlog__timestamp"></span></a><a href="#chatlog__message-container-989675822648524820">23-Jun-22 11:38 PM</a></div>
        <div class="chatlog__content chatlog__markdown"><span class="chatlog__markdown-preserve">僕は次の二つの方法のいずれかを用いています（スナップショットテストはしていませんが、 Xcode Preview のためにやっています）。 ① 一つは、 <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">@StateObject</code> を保持する <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">View</code> とレイアウトする <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">View</code> を分離し、前者が後者を利用する形にすることです。 <code class="chatlog__markdown-pre chatlog__markdown-pre--multiline language-swift">// state 保持用の View とレイアウト用の View を分離する例 struct FooStateView: View { @StateObject private var state: FooViewState&lt;FooService&gt; ... var body: some View { FooView(bar: state.bar, baz: $state.baz) } } struct FooView: View { let bar: Int @Binding var baz: String ... }</code> こうしておけば <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">state</code> とは独立に <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">FooView</code> の任意の状態を簡単に実現できるので、スナップショットテストやプレビューのためのモックが必要なくなります。↑は SwiftUI の例ですが、UIKit の場合でも、外から渡された状態を再現するだけの VC と、 <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">state</code> を保持して状態を伝えるだけの VC とに分離することで、同様のことが実現可能です。 ② もう一つは、公開する <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">state</code> のプロパティをすべて <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">@Publsihed public var</code> にしてしまうことです。そうすれば、スナップショットテストやプレビューの際に、任意の状態の <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">state</code> を簡単に作れます。 <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">UserService</code> 等にはダミーのテスト用実装を渡して何の仕事もさせないようにします。なお、 computed property の場合は setter を作れないので、↓のように republish する必要が生じます。 <code class="chatlog__markdown-pre chatlog__markdown-pre--multiline language-swift">// computed property の代わりに republish が必要になる例 // Before @MainActor public final class FooViewState&lt;FooService: FooServiceProtocol&gt;: ObserbalbleObject { @Published public var baz: String = "" public var isQux: Bool { baz.isEmpty } ... } // After @MainActor public final class FooViewState&lt;FooService: FooServiceProtocol&gt;: ObserbalbleObject { @Published public var baz: String = "" @Published public var isQux: Bool = false ... init(...) { ... $baz.map(\.isEmpty).assign(to: &amp;$isQux) // republish } ... } </code> ①②とも一長一短で、①は実装が冗長になりがちです。②は外から触っていいものといけないもの（本来 <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">private(set)</code> であるべきもの）の区別が付きづらいです。テスト以外のケースで、本来メソッドを通して状態を変更しなければならないプロパティを setter で変更してしまうと、 <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">state</code> の状態を壊してしまう可能性があります。 <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">@testable import</code> を前提に、 <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">internal(set)</code> にするのも良いかもしれません。</span></div>
        <div class="chatlog__reactions">
          <div class="chatlog__reaction" title="man_bowing"><img class="chatlog__emoji chatlog__emoji--small" alt="🙇‍♂️" src="https://twemoji.maxcdn.com/2/svg/1f647-200d-2642-fe0f.svg" loading="lazy"> <span class="chatlog__reaction-count">1</span></div>
        </div>
      </div>
    </div>
  </div>
</div>