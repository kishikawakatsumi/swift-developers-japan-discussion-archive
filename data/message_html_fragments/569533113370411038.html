<div class="chatlog__message-group">
  <div class="chatlog__author-avatar-container">
    <img class="chatlog__author-avatar" src="https://cdn.discordapp.com/avatars/291075091025100810/39d60f97ea2bca395f1992c42f25107c.png?size=128" alt="Avatar" loading="lazy">
  </div>
  <div class="chatlog__messages">
    <span class="chatlog__author-name" title="kishikawakatsumi#7600" data-user-id="291075091025100810" style="color: rgb(155,89,182)">Kishikawa Katsumi</span>
    <span class="chatlog__timestamp">21-Apr-19 02:25 PM</span>
    <div class="chatlog__message " data-message-id="569529026721480719" id="message-569529026721480719" title="Message sent: 21-Apr-19 02:25 PM">
      <div class="chatlog__content">
        <div class="markdown">
          <span class="preserve-whitespace">この段階でテキストがトークンに分割されたものが手に入ります。 <div class="pre pre--multiline nohighlight">▿ 1498 elements ▿ 0 : ( ▿ 1 : source_file ▿ 2 : "/Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift" ▿ 3 : __ ▿ 4 : ( ▿ 5 : struct_decl ▿ 6 : range ▿ 7 : = ▿ 8 : /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:1:8 - line:17:1 ▿ 9 : "Country" ▿ 10 : interface ▿ 11 : type ▿ 12 : = ▿ 13 : 'Country.Type' ...</div></span>
        </div>
      </div>
    </div>
    <div class="chatlog__message " data-message-id="569529354183507991" id="message-569529354183507991" title="Message sent: 21-Apr-19 02:26 PM">
      <div class="chatlog__content">
        <div class="markdown">
          <span class="preserve-whitespace"><span class="pre pre--inline">ASTLexer</span> がこのトークンの配列をツリー構造にします。Lexerといってますが、ツリー構造に変換するだけです。</span>
        </div>
      </div>
    </div>
    <div class="chatlog__message " data-message-id="569530160848830464" id="message-569530160848830464" title="Message sent: 21-Apr-19 02:29 PM">
      <div class="chatlog__content">
        <div class="markdown">
          <span class="preserve-whitespace">
            <div class="pre pre--multiline nohighlight">[(, source_file, "/Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift"] [(, struct_decl, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:1:8 - line:17:1, "Country", interface, type, =, 'Country.Type', access, =, public, non-resilient] [(, pattern_binding_decl, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:12 - line:2:22] [(, pattern_typed, type, =, 'String'] [(, pattern_named, type, =, 'String', 'code', )] [(, type_ident] [(, component, id, =, 'String', bind, =, Swift.(file).String))))] [(, var_decl, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:16 - line:2:16, "code", type, =, 'String', interface, type, =, 'String', access, =, public, let, readImpl, =, stored, immutable] [(, accessor_decl, implicit, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:16 - line:2:16, 'anonname=0x10a8205a8', interface, type, =, '(Country) -&gt; () -&gt; String', access, =, public, get_for, =, code] [(, parameter, "self", interface, type, =, 'Country', )] [(, parameter_list, )] [(, brace_stmt, implicit, range, =, /Users/katsumi/Documents/XcodeProjects/SwiftPowerAssert/Fixtures/Atlas/Sources/Atlas/Atlas.swift:2:16 - line:2:16] [(, return_stmt, implicit] ...</div> こんな感じです。これでツリー構造とノードの種別や属性情報がプログラムから扱える形になりました。
          </span>
        </div>
      </div>
    </div>
    <div class="chatlog__message " data-message-id="569531822166376480" id="message-569531822166376480" title="Message sent: 21-Apr-19 02:36 PM">
      <div class="chatlog__content">
        <div class="markdown">
          <span class="preserve-whitespace">ここまではそんなに難しくなくて、大変なのはソースコードから生成されるASTが難しいので、この情報を使っていくところです。 わかりやすいところで<span class="pre pre--inline">struct_decl</span>とか<span class="pre pre--inline">var_decl</span>、<span class="pre pre--inline">call_expr</span>、<span class="pre pre--inline">member_ref_expr</span>、<span class="pre pre--inline">dot_syntax_call_expr</span>などです。それ以外に膨大な種類のノードがあるので、全部に対応するのはとても大変なので、必要に応じてノードをフィルタして使っていく、というのが良いかと私は考えています。</span>
        </div>
      </div>
    </div>
    <div class="chatlog__message " data-message-id="569533108232257536" id="message-569533108232257536" title="Message sent: 21-Apr-19 02:41 PM">
      <div class="chatlog__content">
        <div class="markdown">
          <span class="preserve-whitespace">その必要なところだけ使う、というのをやっているのがASTParserで、 <div class="pre pre--multiline nohighlight">private func parseSourceFileNode(node sourceFileNode: ASTNode&lt;[ASTToken]&gt;) -&gt; AST { var declarations = [Declaration]() for node in sourceFileNode.children { for token in node.value { switch (token.type, token.value) { case (.token, "top_level_code_decl"): declarations.append(.topLevelCode(parseTopLevelCodeDeclarationNode(node: node))) case (.token, "import_decl"): declarations.append(.import(parseImportDeclarationNode(node: node))) case (.token, "struct_decl"): declarations.append(.struct(parseStructDeclarationNode(node: node))) case (.token, "class_decl"): declarations.append(.class(parseClassDeclarationNode(node: node))) case (.token, "enum_decl"): declarations.append(.enum(parseEnumDeclarationNode(node: node))) case (.token, "extension_decl"): declarations.append(.extension(parseExtensionDeclarationNode(node: node))) case (.token, "func_decl"): declarations.append(.function(parseFunctionDeclarationNode(node: node))) default: break } } } return AST(declarations: declarations) }</div> のようにまずStructやClass宣言を拾って、そのあと例えば関数だったら</span>
        </div>
      </div>
    </div>
    <div class="chatlog__message " data-message-id="569533113370411038" id="message-569533113370411038" title="Message sent: 21-Apr-19 02:41 PM">
      <div class="chatlog__content">
        <div class="markdown">
          <span class="preserve-whitespace">
            <div class="pre pre--multiline nohighlight">private func parseFunctionDeclarationNode(node: ASTNode&lt;[ASTToken]&gt;) -&gt; FunctionDeclaration { let tokens = node.value let name = parseString(tokens: tokens) ?? parseSymbol(tokens: tokens) let accessLevel = parseAccessLevel(tokens: tokens) var parameters = [Parameter]() var body = [Statement]() for node in node.children { for token in node.value { switch (token.type, token.value) { case (.token, "parameter_list"): parameters.append(contentsOf: parseParameterListNode(node: node)) case (.token, "brace_stmt"): body.append(.expression(parseExpressionNode(node: node))) default: break } } } return FunctionDeclaration(accessLevel: accessLevel, name: name!, parameters: parameters, body: body) }</div> パラメータやステートメントをさらに拾っていく、としています。 一番大変なのがこのParser部分を作っていくところだと思います。ここは自分が利用する情報を探しながらトライアルアンドエラーで書いていくことになります。
          </span>
        </div>
      </div>
    </div>
  </div>
</div>